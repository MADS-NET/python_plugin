/*
  _____ _ _ _                    _             _
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/
# A Template for PythonFilterPlugin, a Filter Plugin
# Generated by the command: plugin -t filter -d python_plugin python_filter
# Hostname: Fram-IV.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2024-08-30T09:10:53.294+0200
# NOTICE: MADS Version 1.2.0
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
// other includes as needed here
#include <cppy3/cppy3.hpp>
#include <cppy3/utils.hpp>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "python_filter"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class PythonFilterPlugin : public Filter<json, json> {

public:
  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  return_type load_data(json const &input, string topic = "") override {
    cppy3::exec("MADS.load_data(" + input.dump() + ")");
    cout << "Loaded data: " << input.dump() << endl;
    return return_type::success;
  }

  return_type process(json &out) override {
    out.clear();

    if (!_agent_id.empty())
      out["agent_id"] = _agent_id;

    cppy3::Var result;
    try {
      result = cppy3::exec("MADS.process()");
      out = json::parse(result.toString());
    } catch (cppy3::PythonException &e) {
      cerr << "Error processing data: " << e.what();
      return return_type::error;
    } catch (nlohmann::json::exception &e) {
      cerr << "Error parsing result: " << cppy3::WideToUTF8(result.toString())
           << endl << e.what();
      return return_type::error;
    }
    
    return return_type::success;
  }

  void set_params(void const *params) override {
    Filter::set_params(params);
    _params["script_file"] = "filter.py";
    _params.merge_patch(*(json *)params);
    _script_file = _params["script_file"].get<string>();

    prepare_python();
  }

  void prepare_python() {
    cppy3::eval(R"(
import json
class MADS_base:
  data = {}

  def __init__(self):
    print("Note that there is typically no need to instantiate MADS class")
  
  @classmethod
  def load_data(cls, data_str):
    print("Loading data: ", data_str)
    # cls.data = json.loads(data_str)
    cls.data = {"AX": 1, "AY": 2, "AZ": 3}

  @classmethod
  def process(cls):
    raise Exception("This method must be implemented in the MADS class")

)");
    try {
      cppy3::execScriptFile(_script_file);
    } catch (cppy3::PythonException &e) {
      cerr << "Error loading python script " << _script_file << ": "
           << e.what();
      exit(EXIT_FAILURE);
    }
  }

  map<string, string> info() override { return {}; };

private:
  cppy3::PythonVM _python;
  string _script_file;
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(PythonFilterPlugin, json, json);

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

*/

int main(int argc, char const *argv[]) {
  PythonFilterPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["script_file"] = "python/filter.py";
  if (argc > 1) {
    params["script_file"] = argv[1];
  }

  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {{"AX", 1}, {"AY", 2}, {"AZ", 3}};

  // Set input data
  plugin.load_data(input);
  cout << "Input: " << input.dump(2) << endl;

  // Process data
  plugin.process(output);
  cout << "Output: " << output.dump(2) << endl;

  return 0;
}
